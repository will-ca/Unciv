<!-- This file is read by main.py to dynamically set some docstrings. Keep that in mind if editing, renaming, or deleting this file. -->

The Python API described by this document is built on the [IPC protocols and execution model described in `/core/Module.md`](../../../../../core/Module.md#package-comuncivscriptingprotocol).

---

## Overview

There are basically two types of Python objects in this API:

	*	Wrappers.
	*	Tokens.

---

## Foreign Object Wrappers

A **wrapper** is an object that stores a list of attribute names, keys, and function call parameters corresponding to a path in the Kotlin/JVM namespace. E.G.: `"civInfo.civilizations[0].population.setPopulation"` is a string representation of a wrapped path that begins with two attribute accesses, followed by one array index, and two more attribute names.

A wrapper object does not store any more values than that. When it is evaluated, it uses a simple IPC protocol to request an up-to-date real value from the game's Kotlin code. The `unciv_lib.api.real()`/`unciv_pyhelpers.real()` function can be used to manually get a real Python value from a foreign instance wrapper.

However, because the wrapper class implements many Magic Methods that automatically call its evaluation method, many programming idioms common in Python are possible with them even without manual evaluation. Comparisons, equality, arithmetic, concatenation, in-place operations and more are all supported.

Accessing an attribute on a wrapper object returns a new wrapper object that has an additional name set to "Property" at the end of its path list. Performing an array or dictionary index returns a new wrapper with an additional "Key" element in its path list.

```python3
print(civInfo) # Wrapper object.
print(civInfo.cities[0]) # Also a wrapper object, with two extra path elements.
print(civInfo.cities[0].isCapital) # Still a wrapper object, with another extra path element.
```

Calling a wrapper object as a function or method also creates a new path list with an extra "Call" element at the end. But in this case, the new path list is immediately sent as a request to Kotlin/the JVM instead of being used in a new wrapper object, and the returned value is the naked result from the requested function call in the Kotlin/JVM namespace.

```python3
print(civInfo.cities[0].isCapital()) # Goes through four wrapper objects, but ultimately sends its path as a request on the function call, and returns a real value.
```

Likewise, assigning to an attribute or an index/key on a wrapper object sends an IPC request to assign to the Kotlin/JVM value at its path, instead of modifying the wrapper object.

```python3
civInfo.cities[0].name = "Metropolis"
# Uses IPC request to modify Kotlin/JVM property.

civInfo.cities[0].cityConstructions.constructionQueue[0] = "Missile Cruiser"
# Uses IPC request to modify Kotlin/JVM container.
```

When a Kotlin/JVM class implements a property for size or keys, Python wrappers for its instances can be iterated like a `tuple` or a `dict`, such as in `for` loops and iterable comprehensions.

```python3
print([real(city.name)+str(real(city.population.population)) for city in civInfo.cities])
print({name: real(empire.cities and empire.cities[0]) for name, empire in gameInfo.ruleSet.nations.entries()})
```

In the Python implementation of the IPC protocol, wrapper objects are automatically evaluated and serialized as their resolved values when used in IPC requests and responses.

```python3
somePythonVariable = gameInfo.turns
# Assigns a wrapper object to somePythonVariable. Does not evaluate real value for `gameInfo.turns`.

civInfo.tech.freeTechs = real(gameInfo.turns)
# Explicitly evaluate gameInfo.turns before using it in IPC assignment.
# 1. Makes IPC request for gameInfo.turns.
# 2. Receives IPC response for gameInfo.turns as integer.
# 3. Makes IPC request to assign resulting integer to civInfo.tech.freeTechs.

civInfo.techs.freeTechs = gameInfo.turns
# Does the same thing as above, because the gameInfo.turns wrapper object is resolved at the point of serialization.
```

The magic methods implemented on wrapper objects also automatically evaluate wrappers into real Python values if they are used in Python-space operations.

```python3
gameInfo.turns + 5
5 + gameInfo.turns
x = 5
x += gameInfo.turns
# All works, because the gameInfo.turns wrapper automatically sends and receives IPC packets to resolve into its real value as an integer when it's added.
```

In-place operations on wrapper objects are implemented by performing the operation using Python semantics and then making an IPC request to assign the result in Kotlin/the JVM.

```python3
gameInfo.turns += 5

# Equivalent to:

gameInfo.turns = real(gameInfo.turns) + real(5)
```

---

## Foreign Object Tokens

A **token** is a string that has been generated by `InstanceTokenizer.kt` to represent a Kotlin instance.

The `unciv_lib.api.isForeignToken()`/`unciv_pyhelpers.api.isForeignToken()` function can be used to check whether a Python object is either a foreign token string or a wrapper that resolves to a foreign token string.

When a Kotlin/JVM path requested by a script resolves to an immutable primative like a number or boolean, or something that is otherwise practical to serialize, then the value returned to Python is usually a real object.

However, if the value requested is an instance of a complicated Kotlin/JVM class, then the IPC protocol instead creates a unique string to identify it.

```python3
isForeignToken("Some random string.")
# False.

isForeignToken(uncivGame.version)
# False. Version is stored as a simple string.

isForeignToken(gameInfo.turns)
# False. Turn count is stored as a simple integer.

isForeignToken(real(uncivGame))
# True. Unserializable instances are turned into token strings on evaluation.

isForeignToken(civInfo.getWorkerAutomation())
# True. This method returns a complicated type that gets turned into a token string.

isForeignToken(uncivGame)
# True. This is actually a wrapper, but `isForeignToken` returns True based on evaluated results.
```

The original instance is stored in the JVM in a mapping as a weak reference. The string doesn't have any special properties as a Python object. But if it is sent back to Kotlin/the JVM at any point, then it will be parsed and substituted with the original instance (provided the original instance still exists).

This is meant to allow Kotlin/JVM instances to be, E.G., used as function arguments and mapping keys from scripts.

```python3
civunits = civInfo.getCivUnits()
# List of token strings representing `MapUnit()` instances.

unit = civunits[0]
# Single token string.

civInfo.removeUnit(unit)
# Token string gets get transformed back into original `MapUnit()` when used as function argument.
```

The rules for which classes are serialized as JSON values and which are serialized as token strings may be a little bit fuzzy and variable, as they are designed to maximise use cases.

In general, Kotlin/JVM instances that *can* be cast into a type compatible with a JSON type will be serialized as such— Unless they are of classes defined within the Unciv packages themselves, in which case they will always be tokenized. The exemption for certain classes prevents everything that inherits from iterable interfaces— Like `Building()`, which inherits from `Stats:Iterable<Stats.StatValuePair>`— From being stripped down into JSON arrays when having access to their members and instances is much more useful.

---

## Assigning Tokens to Paths to Get Wrappers

Sometimes, you may want to access a path or call a method on an object that you have only as a token string— For example, an object returned from a foreign function or method call.

Usually this would be impossible because you need a path in order to access foreign attributes. Without a valid path to an object, the wrapper code and the IPC protocol it uses have no way to identify where an object is or what to do with it. In fact, if the Kotlin/JVM code hasn't kept its own references to the object, then the object may not even exist anymore.

To get around this, you can use the foreign token to assign the object it represents to a concrete path.

The `apiHelpers.registeredInstances` helper object can be used for this:

```python3
token = civInfo.cities[0].getCenterTile()
# Token string representing a `TileInfo()` instance.

print(type(token))
# <class 'str'>. Cannot be used for attribute access.

apiHelpers.registeredInstances["centertile"] = token
# Token string gets transformed back into `TileInfo()` in Kotlin/JVM assignment.

print(type(apiHelpers.registeredInstances["centertile"]))
# <class 'ForeignObject'>. A full wrapper with path, that can be used for full attribute, key, and method access.

print(apiHelpers.registeredInstances["centertile"].baseTerrain)
# Successful attribute access.

del apiHelpers.registeredInstances["centertile"]
# Delete the reference so it doesn't become a memory leak.
```

In order to use this technique properly, the assignment of an object to a concrete path should be done within the same REPL loop as the generation of the token used to assign it. This is because the Kotlin code responsible for generating tokens and managing the REPL loop keeps references to all returned objects within each REPL loop. Afterwards, these references are immediately cleared, so any objects that do not have references elsewhere in Kotlin/the JVM are liable to be garbage-collected in between REPL loops.

```python3
>>> apiHelpers.registeredInstances["x"] = apiHelpers.Factories.Vector2(1,2)
>>> worldScreen.mapHolder.setCenterPosition(apiHelpers.registeredInstances["x"], True, True)
# Works, because the instance creation and token-based assignment in Kotlin are done in the same REPL execution.

>>> x = apiHelpers.Factories.Vector2(1,2); civInfo.endTurn(); apiHelpers.registeredInstances["x"] = x
>>> worldScreen.mapHolder.setCenterPosition(apiHelpers.registeredInstances["x"], True, True)
# Also works.
```

```python3
>>> x = apiHelpers.Factories.Vector2(1,2)
>>> apiHelpers.registeredInstances["x"] = x
>>> worldScreen.mapHolder.setCenterPosition(apiHelpers.registeredInstances["x"], True, True)
# May not work, because the created instance has no reference in Kotlin between the first two script executions and can be garbage-collected.

>>> x = apiHelpers.Factories.Vector2(1,2)
>>> worldScreen.mapHolder.setCenterPosition(x, True, True)
# Also may not work.
```

**It is very important that you delete concrete paths you have set after you are done with them.** Any objects held at paths you do not delete will continue to occupy system memory for the remaining run time of the application's lifespan. We can't rely on Python's garbage collection in this case because it doesn't control the Kotlin objects, nor can we rely on the JVM's garbage collector because it doesn't know whether Python code still needs the objects in question, so you will have to manage the memory yourself by keeping a reference as long as you need an object and deleting it to free up memory afterwards.

For any complicated script in Python, it is suggested that you write a context manager class to automatically take care of saving and freeing each object where appropriate.

It is also recommended that all scripts create a separate mapping with a unique and identifiable key in `apiHelpers.registeredInstances`, instead of assigning directly to the top level.

```python3
apiHelpers.registeredInstances["myCoolScript"] = {}

memalloc = apiHelpers.registeredInstances["myCoolScript"]

memalloc["capitaltile"] = civInfo.cities[0].getCenterTile()

worldScreen.mapHolder.setCenterPosition(memalloc["capitaltile"].position, True, True)

del memalloc["capitaltile"]

del apiHelpers.registeredInstances["myCoolScript"]
```

```python3
apiHelpers.registeredInstances["myCoolScript"] = {}

memalloc = apiHelpers.registeredInstances["myCoolScript"]

class MyForeignContextManager:
	def __init__(self, *tokens):
		self.tokens = tokens
		self.memallocKeys = set()
	def __enter__(self):
		for token in self.tokens:
			key = f"{random.random()}_{time.time_ns()}"
			memalloc[key] = token
			self.memallocKeys.add(key)
		return tuple(memalloc[k] for k in self.memallocKeys)
	def __exit__(self, *exc):
		for key in self.memallocKeys:
			del memalloc[key]
		self.memallocKeys.clear()

with MyForeignContextManager(apiHelpers.MapUnit(), ) as mapUnit, :
	mapUnit

del apiHelpers.registeredInstances["myCoolScript"]
```

---

## API Modules

The top-level namespace of the API can be imported as the `unciv` module in any script started running in the same interpreter as it.\
Further tools can be imported as `unciv_pyhelpers`.

This is useful when writing modules that are meant to be imported from the main Unciv Python namespace.

In a file in your `PYTHONPATH`/`sys.path`:

```python3
#MyCoolModule.py

import unciv
import unciv_pyhelpers

def printCivilizations():
	for civ in unciv.gameInfo.civilizations:
		print(f"{unciv_pyhelpers.real(civ.nation.name)}: {len(civ.cities)} cities")
```

In Unciv:

```python3
>>> import MyCoolModule
>>> MyCoolModule.printCivilizations()
```

---

## Other Languages

The Python-specific behaviour is not meant as a hard standard, in that it doesn't have to be copied exactly in any other languages. Some other design may be more suited for ECMAScript, Lua, and other possible backends. If implementing another language, I think some attempt should still be made to keep a similar API and feature equivalence, though.
