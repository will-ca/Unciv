"""
There are basically two types of Python objects in this API:

	*	Wrappers.
	*	Tokens.

---

A **wrapper** is an object that stores a list of attribute names, keys, and function call parameters corresponding to a path in the Kotlin/JVM namespace. E.G.: `"civInfo.civilizations[0].population.setPopulation"` is a string representation of a wrapped path that begins with two attribute accesses, followed by one array index, and two more attribute names.

A wrapper object does not store any more values than that. When it is evaluated, it uses a simple IPC protocol to request an up-to-date real value from the game's Kotlin code. The `unciv.api.real()` function can be used to manually get a real Python value from a foreign instance wrapper.

However, because the wrapper class implements many Magic Methods that automatically call its evaluation method, many programming idioms common in Python are possible with them even without manual evaluation. Comparisons, equality, arithmetic, concatenation, inplace operations and more are all supported.

Accessing an attribute on a wrapper object returns a new wrapper object that has an additional name set to "Property" at the end of its path list. Performing an array or dictionary index returns a new wrapper with an additional "Key" element in its path list.

```python3
print(civInfo) # Wrapper object.
print(civInfo.cities[0]) # Also a wrapper object, with two extra path elements.
print(civInfo.cities[0].isCapital) # Still a wrapper object, with another extra path element.
```

Calling a wrapper object as a function or method also creates a new path list with an extra "Call" element at the end. But in this case, the new path list is immediately sent as a request to Kotlin/the JVM instead of being used in a new wrapper object, and the returned value is the naked result from the requested function call in the Kotlin/JVM namespace.

```python3
print(civInfo.cities[0].isCapital()) # Goes through four wrapper objects, but ultimately sends its path as a request on the function call, and returns a real value.
```

Likewise, assigning to an attribute or an index/key on a wrapper object sends an IPC request to assign to the Kotlin/JVM value at its path, instead of modifying the wrapper object.

```python3
civInfo.cities[0].name = "Metropolis"
# Uses IPC request to modify Kotlin/JVM object.

civInfo.cities[0].cityConstructions.constructionQueue[0] = "Missile Cruiser"
# Uses IPC request to modify Kotlin/JVM container.
```

When a Kotlin/JVM class implements a property for size or keys, Python wrappers for its instances can be iterated like a `tuple` or a `dict`, such as in `for` loops and iterable comprehensions.

```python3
print([real(city.name)+str(real(city.population.population)) for city in civInfo.cities])
print({name: real(empire.cities and empire.cities[0]) for name, empire in gameInfo.ruleSet.nations.entries()})
```

---

A **token** is a string that has been generated by `InstanceTokenizer.kt` to represent a Kotlin instance.

The `unciv.api.isForeignToken()` function can be used to check whether a Python object is either a foreign token string or a wrapper that resolves to a foreign token string.

When a Kotlin/JVM path requested by a script resolves to an immutable primative like a number or boolean, or something that is otherwise practical to serialize, then the value returned to Python is usually a real object.

However, if the value requested is an instance of a complicated Kotlin/JVM class, then the IPC protocol instead creates a unique string to identify it.

```python3
isForeignToken("Some random string.")
# False.

isForeignToken(uncivGame.version)
# False. Version is stored as a simple string.

isForeignToken(gameInfo.turns)
# False. Turn count is stored as a simple integer.

isForeignToken(real(uncivGame))
# True. Unserializable instances are turned into token strings on evaluation.

isForeignToken(civInfo.getWorkerAutomation())
# True. This method returns a complicated type that gets turned into a token string.

isForeignToken(uncivGame)
# True. This is actually a wrapper, but `isForeignToken` returns True based on evaluated results.
```

The original instance is stored in the JVM in a mapping as a weak reference. The string doesn't have (m)any special properties as a Python object. But if it is sent back to Kotlin/the JVM at any point, then it will be parsed and substitued with the original instance (provided the original instance still exists).

This is meant to allow Kotlin/JVM instances to be, E.G., used as function arguments and mapping keys from scripts.

```python3
civunits = civInfo.getCivUnits()
# List of token strings representing `MapUnit()` instances.

unit = civunits[0]
# Single token string.

civInfo.removeUnit(unit)
# Token string gets get transformed back into original `MapUnit()` when used as function argument.
```

The rules for which classes are serialized as JSON values and which are serialized as token strings may be a little bit fuzzy and variable, as they are designed to maximise use cases.

In general, Kotlin/JVM instances that *can* be cast into a type compatible with a JSON type will be serialized as such— Unless they are of classes defined within the Unciv packages themselves, in which case they will always be tokenized. The exemption for certain classes prevents everything that inherits from iterable interfaces— Like `Building()`, which inherits from `Stats:Iterable<Stats.StatValuePair>`— From being stripped down into JSON arrays when having having references to and members of their instances is much more useful.

---

Sometimes, you may want to access a path or call a method on an object that you have only as a token string— For example, an object returned from a foreign function or method call.

Usually this would be impossible because you need a path in order to access foreign attributes. Without a valid path to an object, the wrapper code and the IPC protocol it uses have no way to identify where an object is or what to do with it. In fact, if the Kotlin/JVM code hasn't kept its own references to the object, then the object may not even exist anymore.

To get around this, you can use the foreign token to assign the object it represents to a concrete path.

The `apiHelpers.registeredInstances` helper object can be used for this:

```python3
token = civInfo.cities[0].getCenterTile()
# Token string representing a `TileInfo()` instance.

print(type(token))
# <class 'str'>. Cannot be used for attribute access.

apiHelpers.registeredInstances["centertile"] = token
# Token string gets transformed back into `TileInfo()` in Kotlin/JVM assignment.

print(type(apiHelpers.registeredInstances["centertile"]))
# <class 'ForeignObject'>. Is now a full wrapper with path, and can be used for full attribute, key, and method access.

print(apiHelpers.registeredInstances["centertile"].baseTerrain)
# Successful attribute access.

del apiHelpers.registeredInstances["centertile"]
# Delete the reference so it doesn't become a memory leak.
```

In order to use this technique properly, the assignment of an object to a concrete path should be done within the same REPL loop as the generation of the token used to assign it. This is because the Kotlin code responsible for generating tokens and managing the REPL loop keeps references to all returned objects within each REPL loop. Afterwards, these references are immediately cleared, so any objects that do not have references elsewhere in Kotlin/the JVM are liable to be garbage-collected.

**It is very important that you delete concrete paths you have set after you are done with them.** Any objects held at paths you do not delete will continue to occupy system memory for the remaining run time of the application's lifespan. We can't rely on Python's garbage collection in this case because it doesn't control the Kotlin objects, nor can we rely on the JVM's garbage collector because it doesn't know whether Python code still needs the objects in question, so you will have to manage the memory yourself by keeping a reference as long as you need an object and deleting it to free up memory afterwards.

For any complicated script in Python, it is suggested that you write a context manager class to automatically take care of saving and freeing each object where appropriate.

It is also recommended that all scripts create a separate mapping with a unique and identifiable key in `apiHelpers.registeredInstances`, instead of assigning directly to the top level.

```python3
apiHelpers.registeredInstances["myCoolScript"] = {}

memalloc = apiHelpers.registeredInstances["myCoolScript"]

memalloc["capitaltile"] = civInfo.cities[0].getCenterTile()

worldScreen.mapHolder.setCenterPosition(memalloc["capitaltile"].position, True, True)

del memalloc["capitaltile"]

del apiHelpers.registeredInstances["myCoolScript"]
```

---

Some of this may not yet be fully implemented.

The Python-specific behaviour is also not meant as a hard standard, in that it doesn't have to be copied exactly in any other languages. Some other design may be more suited for ECMAScript, Lua, and other possible backends. If implementing another language, I think some attempt should still be made to keep a similar API and feature parity, though.

"""

try:

	# This is all a very messy code structure, but it's literally the most surface-facing part of the entire scripting API on which nothing depends and failures are easy to debug, and since it's making changes to `sys`, I'm not sure how I feel about hiding parts of it in a module.
	# Otherwise, I would clean it up a bit and move it into `api.py`.
	
	import sys, json

	stdout = sys.stdout
	
	import unciv
	
	try:
		unciv.wrapping.ForeignObject.__doc__ = (unciv.wrapping.ForeignObject.__doc__ or "") + "\n\n\n---\n\n" + __doc__
	except:
		pass
	
	foreignActionSender = unciv.ipc.ForeignActionSender()
	
	
	apiScope = {}
	# TODO Use an empty/dummy module's `.__dict__`, so scripts have something in the module map that they can import.
	
	apiScope.update(unciv.api.Expose)
	
	apiScope['help'] = lambda thing=None: print(__doc__) if thing is None else help(thing)
	
	
	class fsdebug:
		pass
	
	fsdebug = fsdebug()
	fsdebug.__dict__ = apiScope
	
	foreignAutocompleter = unciv.autocompletion.PyAutocompleteManager(apiScope, **unciv.api._autocompleterkwargs)
	
	class ForeignUncivActionReplReceiver(unciv.ipc.ForeignActionReceiver):
		def populateApiScope(self):
			names = dir(unciv.wrapping.ForeignObject((), foreignrequester=foreignActionSender.GetForeignActionResponse))
			for n in names:
				if n not in self.scope:
					self.scope[n] = unciv.wrapping.ForeignObject(n, foreignrequester=foreignActionSender.GetForeignActionResponse)
		def passMic(self):
			"""Send a 'PassMic' packet."""
			foreignActionSender.SendForeignAction({'action':None, 'identifier': None, 'data':None, 'flags':('PassMic',)})
		@unciv.ipc.receiverMethod('motd', 'motd_response')
		def EvalForeignMotd(self, packet):
			self.populateApiScope()
			self.passMic()
			return f"""
sys.implementation == {str(sys.implementation)}

Press [TAB] at any time to trigger autocompletion at the current cursor position, or display help text for an empty function call.

"""
		@unciv.ipc.receiverMethod('autocomplete', 'autocomplete_response')
		def EvalForeignAutocomplete(self, packet):
			assert 'PassMic' in packet.flags, f"Expected 'PassMic' in packet flags: {packet}"
			res = foreignAutocompleter.GetAutocomplete(packet.data["command"], packet.data["cursorpos"])
			self.passMic()
			return res
		@unciv.ipc.receiverMethod('exec', 'exec_response')
		def EvalForeignExec(self, packet):
			line = packet.data
			assert 'PassMic' in packet.flags, f"Expected 'PassMic' in packet flags: {packet}"
			with unciv.ipc.FakeStdout() as fakeout:
				print(f">>> {str(line)}")
				try:
					try:
						code = compile(line, 'STDIN', 'eval')
					except SyntaxError:
						exec(compile(line, 'STDIN', 'exec'), self.scope, self.scope)
					else:
						print(eval(code, self.scope, self.scope))
				except Exception as e:
					print(unciv.utils.formatException(e))
				finally:
					self.passMic()
					return fakeout.getvalue()
				
		@unciv.ipc.receiverMethod('terminate', 'terminate_response')
		def EvalForeignTerminate(self, packet):
			return None

	foreignActionReceiver = ForeignUncivActionReplReceiver(scope=apiScope)
	
	foreignActionReceiver.ForeignREPL()
	# Disable this to run manually with `python3 -i main.py` for debug.
	
	raise RuntimeError("No REPL. Did you forget to uncomment a line in `main.py`?")
	
except Exception as e:
#	try:
#		import unciv.utils
#		exc = unciv.utils.formatException(e)
#		# Disable this. A single line with undefined format is more likely to be printed than multiple.
#	except:
#		exc = repr(e)
	print(f"Fatal error in Python interepreter: {repr(e)}", file=stdout, flush=True)
