name: UncivBot

on:
  issue_comment:
  workflow_dispatch:

jobs:
  update_wiki:
    if: github.event.comment.body == 'update wiki'
    runs-on: ubuntu-latest
    steps:
      - name: Update Wiki.
        # Compare to https://github.com/SwiftDocOrg/github-wiki-publish-action/blob/v1/entrypoint.sh
        run: |
          set -euo pipefail # Immediate exit on command errors and unset variables.
          set -x # Print out each executed command. THIS WILL LEAK THE PERSONAL ACCESS TOKEN SECRET VIA $GH_TOKEN and $WIKI_URL!

          for REQUIRED_ENV_VAR in GITHUB_ACTOR GITHUB_SERVER_URL GITHUB_REPOSITORY GH_TOKEN CODE_DIR WIKI_DIR WIKI_IN_CODE_REPO PR_AUTHOR PR_TITLE PR_NUMBER; do
            if [ -z "$(eval "echo \$$REQUIRED_ENV_VAR")" ]; then
              echo "ERROR: \$$REQUIRED_ENV_VAR is not set."
              exit 1
            fi
          done

          CODE_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}.git"
          WIKI_URL="https://${GH_TOKEN}@${GITHUB_SERVER_URL#https://}/${GITHUB_REPOSITORY}.wiki.git"

          echo "Cloning repository: $CODE_URL"
          git clone "$CODE_URL" "$CODE_DIR"
          echo "Cloning Wiki."
          git clone "$WIKI_URL" "$WIKI_DIR"

          echo 'Running `rsync`.'
          rsync -ac --delete --exclude '.git*' "${CODE_DIR}${WIKI_IN_CODE_REPO}" "WIKI_DIR/"

          echo "Formatting Markdown files in $WIKI_DIR."
          cd "$WIKI_DIR"

          for f in *.md; do
            if [ -e "$f" ]; then
              echo "Formatting $f links."
              # Convert AS/GH code browser inter-page links to GH Wiki links by stripping `.md` extensions.
              sed -ie 's|\(](\./[^)]*\)\.md|\1|g' "$f"
              # Convert AS/GH code browser repo file links to GH Wiki links by prepending repo browser to absolute links.
              sed -ie 's|](/|](https://github.com/${GITHUB_REPOSITORY}/tree/master/|g' "$f"
            else # When glob produces no matches, you just get the glob pattern instead.
              echo "Skipping non-existent file $f."
            fi
          done

          echo "Finished formatting Markdown files."

          git config user.name "$GITHUB_ACTOR"
          git config user.email "$GITHUB_ACTOR@users.noreply.github.com"
          
          git remote get-url origin

          echo "Adding files to Git."
          git add .
          echo "Committing changes."
          git status | cat
          git diff --stat --cached | cat # IDK If Git might try to enter the interactive viewer without a pipe output. Probably not, but play it safe.
          git log | head -100
          git commit -m "${PR_AUTHOR}: ${PR_TITLE} (#${PR_NUMBER})"
          echo "Pushing changes."
          git push
        env:
          GH_TOKEN: ${{ secrets.ACTIONS_ACCESS_TOKEN }}
          CODE_DIR: CodeRepo
          WIKI_DIR: WikiRepo
          WIKI_IN_CODE_REPO: /docs/wiki
          PR_AUTHOR: ${{ github.event.issue.user.login }}
          # I think directly putting these in the script would let quotes in PR title break the script.
          PR_TITLE: ${{ github.event.issue.title }}
          PR_NUMBER: ${{ github.event.issue.number }}
  summary:
    if: github.event_name == 'issue_comment' && github.event.comment.body == 'summary'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v3
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            var result = await github.repos.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 50 });
            var commitSummary = "";
            var ownerToCommits = {}
            var reachedPreviousVersion = false
            result.data.forEach(commit => {
              if (reachedPreviousVersion) return
              var author = commit.author.login
              if (author=="uncivbot[bot]") return
              var commitMessage = commit.commit.message.split("\n")[0];
          
              if (commitMessage.match(/^\d+\.\d+\.\d+$/)){ // match EXACT version, like 3.4.55  ^ is for start-of-line, $ for end-of-line
                reachedPreviousVersion=true
                console.log(commitMessage)
                return
              }
              if (commitMessage.startsWith("Merge ") || commitMessage.startsWith("Update ")) return
              commitMessage = commitMessage.replace(/\(\#\d+\)/,"") // match PR auto-text, like (#2345)
              if (author != context.repo.owner){
                if (ownerToCommits[author] == undefined) ownerToCommits[author]=[]
                ownerToCommits[author].push(commitMessage)
              }
              else commitSummary += "\n\n" + commitMessage
            });
            Object.entries(ownerToCommits).forEach(entry => {
              const [author, commits] = entry;
              if (commits.length==1) commitSummary += "\n\n" + commits[0] + " - By "+author
              else {
                commitSummary += "\n\nBy "+author+":"
                commits.forEach(commitMessage => { commitSummary += "\n- "+commitMessage })
              }
            })
            github.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commitSummary
            })

  merge_translations:
    if: github.event_name == 'workflow_dispatch' || github.event.comment.body == 'merge translations'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v3
        with:
          # SO, the story is that when using the default access token you CANNOT merge PRs from forks.
          # _Badly_ documented in multiple places, including here: https://docs.github.com/en/actions/reference/authentication-in-a-workflow
          # To get around this, we created a Personal Access Token,
          #  put it as one of the secrets in the repo settings (https://github.com/yairm210/Unciv/settings/secrets/actions),
          #  and use that instead.
          github-token: ${{ secrets.ACTIONS_ACCESS_TOKEN }}
          script: |
            
            const repo = {
                  owner: context.repo.owner,
                  repo: context.repo.repo }
            
            async function branchExists(branchName) {
              try {
                await github.git.getRef({...repo, ref: 'heads/' + branchName })
                return true
              } catch (err) {
                return false
              }
            }

            async function getDefaultBranch() {
              var repoData = await github.repos.get(repo)
              return repoData.data.default_branch
            }
            
            var translations = "translations"

            async function createTranslationBranchIfNeeded() {
              if (await branchExists(translations)) return
              var defaultBranch = await getDefaultBranch()
              
              var currentHead = await github.git.getRef({...repo, ref: 'heads/' + defaultBranch })
              
              var currentSha = currentHead.data.object.sha
              console.log("Current sha: " + currentSha)
              
              await github.git.createRef({...repo,
                ref: `refs/heads/`+translations,
                sha: currentSha })
              
              await github.issues.createComment({...repo,
                issue_number: context.issue.number,
                body: 'Translations branch created' })
            }
            
            async function mergeExistingTranslationsIntoBranch(){
              var translationPrs = await github.pulls.list({ ...repo, state: "open" })
              
              // When we used a forEach loop here, only one merge would happen at each run,
              //  because we essentially started multiple async tasks in parallel and they conflicted.
              // Instead, we use X of Y as per https://stackoverflow.com/questions/37576685/using-async-await-with-a-foreach-loop
              for (const pr of translationPrs.data) {
                if (pr.labels.some(label => label.name == "mergeable translation"))
                  await tryMergePr(pr)
              }
            }
            
            async function tryMergePr(pr){
              if (pr.base.ref != translations)
                await github.pulls.update({ ...repo,
                  pull_number: pr.number,
                  base: translations })
              
              try {
                await github.pulls.merge({...repo,
                  pull_number: pr.number,
                  merge_method: "squash" })
                console.log("Merged #"+pr.number+", "+pr.title)
              } catch (err) {
                console.log(err)
              }
                
            }
                        
            
            async function createTranslationPrIfNeeded() {
              var translationPulls = await github.pulls.list({...repo,
                  state: "open",
                  head: context.repo.owner + ":" + translations });

              if (translationPulls.data.length == 0) {
                var defaultBranch = await getDefaultBranch(context);
                await github.pulls.create({...repo,
                  title: "Translations update",
                  head: translations,
                  base: defaultBranch });

                await github.issues.createComment({...repo,
                  issue_number: context.issue.number,
                  body: 'Translations PR created' });
              }
            }
                      
            await createTranslationBranchIfNeeded()
            await mergeExistingTranslationsIntoBranch()
            await createTranslationPrIfNeeded()
  
